package edu.eckerd.integrations.slate.core

import akka.actor.ActorSystem
import akka.http.scaladsl.model.{HttpRequest, HttpResponse, ResponseEntity, StatusCodes}
import akka.http.scaladsl.model.headers.Authorization
import akka.http.scaladsl.unmarshalling.{Unmarshal, Unmarshaller}
import akka.stream.ActorMaterializer
import edu.eckerd.integrations.slate.core.model.SlateResponse

import scala.concurrent.{ExecutionContext, Future}

trait RequestLike[A] extends HasSlateSession {
  type HttpResponder = HttpRequest => Future[HttpResponse]
  def responder: HttpResponder
  implicit val actorSystem: ActorSystem
  implicit val actorMaterializer: ActorMaterializer
  implicit val ec: ExecutionContext
  implicit val um: Unmarshaller[ResponseEntity, SlateResponse[A]]

  /**
    * This generates a Http Request from current information and passes that to the responder.
    * Internal Server Errors are generated by Slick when you request information from a query and no new
    * records have been created since the last run. As such we generate an empty sequence which should be
    * their response.
    * @return A Future of a Sequence of A or an Error if we receive an unexpected error.
    */
  def retrieve(): Future[Seq[A]] = {
    val authorization = Authorization(credentials)
    responder(
      HttpRequest(
        uri = link,
        headers = List(authorization)
      )
    ).flatMap {
      case HttpResponse(StatusCodes.OK, _, entity, _) => Unmarshal(entity).to[SlateResponse[A]].map(_.row)
      case HttpResponse(StatusCodes.InternalServerError, _, _, _) => Future.successful(Seq[A]())
      case HttpResponse(code, _, _, _) => Future.failed(new Throwable(s"Received invalid response code - $code"))
    }
  }

}